#!/bin/sh
#
# Copyright (C) 2009 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

function do_is_allocated() {
    local start=$1
    local size=$(( $2 / 512))
    local step=$3
    local count=$4

    for i in `seq 1 $count`; do
        echo alloc $(( start + i * step )) $size
    done
}

function is_allocated() {
    do_is_allocated "$@" | $QEMU_IO $TEST_IMG | _filter_qemu_io
}

function do_io() {
    local op=$1
    local start=$2
    local size=$3
    local step=$4
    local count=$5
    local pattern=$6

    echo === IO: pattern $pattern >&2
    for i in `seq 1 $count`; do
        echo $op -P $pattern $(( start + i * step )) $size
    done
}

function io_pattern() {
    do_io $@ | $QEMU_IO $TEST_IMG | _filter_qemu_io
}

function io() {
    local start=$2
    local pattern=$(( (start >> 9) % 256 ))

    do_io $@ $pattern | $QEMU_IO $TEST_IMG | _filter_qemu_io
}

function io_zero() {
    do_io $@ 0 | $QEMU_IO $TEST_IMG | _filter_qemu_io
}

function io_test() {
    local op=$1
    local offset=$2

    # Complete clusters (size = 4k)
    io $op $offset 4096 4096 256
    offset=$((offset + 256 * 4096))

    # From somewhere in the middle to the end of a cluster
    io $op $((offset + 2048)) 2048 4096 256
    offset=$((offset + 256 * 4096))

    # From the start to somewhere in the middle of a cluster
    io $op $offset 2048 4096 256
    offset=$((offset + 256 * 4096))

    # Completely misaligned (and small)
    io $op $((offset + 1024)) 2048 4096 256
    offset=$((offset + 256 * 4096))

    # Spanning multiple clusters
    io $op $((offset + 2048)) 8192 12288 64
    offset=$((offset + 64 * 12288))

    # Spanning multiple L2 tables
    # L2 table size: 512 clusters of 4k = 2M
    io $op $((offset + 2048)) 4194304 4999680 8
    offset=$((offset + 8 * 4999680))

    if false; then
        true
    fi
}

function io_test2() {
    local orig_offset=$1

    # Pattern (repeat after 9 clusters):
    # used - used - free - used - compressed - compressed - free - free - compressed

    # Write the clusters to be compressed
    echo === Clusters to be compressed [1]
    io_pattern writev $((offset + 4 * 4096)) 4096 $((9 * 4096)) 256 165
    echo === Clusters to be compressed [2]
    io_pattern writev $((offset + 5 * 4096)) 4096 $((9 * 4096)) 256 165
    echo === Clusters to be compressed [3]
    io_pattern writev $((offset + 8 * 4096)) 4096 $((9 * 4096)) 256 165

    mv $TEST_IMG $TEST_IMG.orig
    $QEMU_IMG convert -f $IMGFMT -O $IMGFMT -c $TEST_IMG.orig $TEST_IMG

    # Write the used clusters
    echo === Used clusters [1]
    io_pattern writev $((offset + 0 * 4096)) 4096 $((9 * 4096)) 256 165
    echo === Used clusters [2]
    io_pattern writev $((offset + 1 * 4096)) 4096 $((9 * 4096)) 256 165
    echo === Used clusters [3]
    io_pattern writev $((offset + 3 * 4096)) 4096 $((9 * 4096)) 256 165

    # Read them
    echo === Read used/compressed clusters
    io_pattern readv $((offset + 0 * 4096)) $((2 * 4096)) $((9 * 4096)) 256 165
    io_pattern readv $((offset + 3 * 4096)) $((3 * 4096)) $((9 * 4096)) 256 165
    io_pattern readv $((offset + 8 * 4096)) $((1 * 4096)) $((9 * 4096)) 256 165

    echo === Read zeros
    io_zero readv $((offset + 2 * 4096)) $((1 * 4096)) $((9 * 4096)) 256
    io_zero readv $((offset + 6 * 4096)) $((2 * 4096)) $((9 * 4096)) 256
}
